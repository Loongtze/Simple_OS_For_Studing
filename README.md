## 0x00 基础知识们
### 1.保护模式
咱们前面说过一个模式，那就是实模式，有看过我之前文章的同学可能知道，实模式就是咱们的程序编址都是在物理地址下进行，但是这对于咱们如今程序员实现软件编程和程序共享是十分困难的，因为在不同的机器上使用物理地址很有可能出现程序之间的冲突，并且实模式的寻址也只能支持1MB内存，这对于我们现在的程序肯定是完全不够的，所以这里就需要用到另外一种模式，也就是保护模式。
现在咱们的操作系统的步骤我在这里总结一下，首先是BIOS加载位于磁盘0扇区的MBR，然后MBR加载位于磁盘2扇区的Loader，且到现在为止，他们都是位于实模式下，现在我们继续介绍保护模式。
![](https://ts1.cn.mm.bing.net/th/id/R-C.42b8b4f8c9bce60b3e1c9ca5f27ebbc7?rik=4qpHwCFR9oIuxQ&riu=http%3a%2f%2fpic.616pic.com%2fys_bnew_img%2f00%2f22%2f14%2fpoCVtSyqkb.jpg&ehk=Dzz%2femSXBTDRkncBWPDft9wkyLK%2bhMi1qsRKUXPWnsY%3d&risl=&pid=ImgRaw&r=0)

保护模式为了解决上述实模式遇到的困难，首先那当然是寄存器不能就只有16位了，由于我们实现的是32位操作系统（这里实现32位是因为他相较之于64位会简单些，我实现这个操作系统是为了学习而已，请各位师傅轻喷），这里注意我们在实模式下虽然说寄存器只用到了16位，但并不代表这个寄存器只有16位，实际上寄存器位数取决与你的CPU是多少位的，这里我们实现的是32位系统，也就是32位CPU，所以我们的寄存器实际上是有32位的，实模式只不过只用了他的低16位表示而已。

这里给出扩展了的寄存器，就打比方ax来说，ax代表低16位，eax则代表整个32位寄存器，当然现在有了64位寄存器，那么rax代表的是64位
![](http://imgsrc.baidu.com/super/pic/item/71cf3bc79f3df8dc68887e558811728b461028b9.jpg)
由于咱们的寻址位数扩展的32位，按字节编地址，则咱们的寻址范围大小就有2^32，即为4GB。但这里有个例外，那就是段基地址寄存器他仍然是16位，就是上述S结尾的寄存器们。我们都知道段寄存器是存储某个段的开头地址，所以说这里咱们内存扩展到4GB之后段基址应该不至于不变呐，这里我首先给个结论，那就是此时的段基址寄存器里面所保存的已经不再是基地址了，而是一个被称作选择子的东西，这个选择子我们之后再详细介绍，这里我们只需要知道段基址还是16位寄存器，而且寻址方式还是段基址加上偏移就够了。

但是为啥不能直接给段基址寄存器变为32位然后直接按照实模式那样寻址呢，那是因为在保护模式下，为了突出保护模式这个名称的意思，我们在访问段的时候就必须添加一些适当的约束，比如说访问控制等。所以这些控制条件在一个寄存器下是放不下的，因此就专门设计了一个数据结构————全局描述表。这个表里面没一个表项称为段描述符，其大小为64字节，这个描述符就用来描述自己所对应的那个内存段的起始地址、大小、权限等信息。这个全局描述表由于表示内存所有段信息，所以十分大，因此存在一个叫做GDTR寄存器专门指向表地址。
![](http://imgsrc.baidu.com/super/pic/item/960a304e251f95ca7e0f63728c177f3e66095278.jpg)
这样之后，咱们的段基址寄存器所保存的就不是段基址了，他保存的是所寻址段在全集描述表下的某一个段描述符的索引，我们可以将全局描述表看作一个数组，然后每个段描述符是其中的元素，我们此时要寻找那个段描述符只需要给出下标索引即可，咱们的段基址寄存器现在就保存的是这个下标，他还有个名字那就是选择子。
这里还有亮点需要说出：
1. 段描述符位于内存当中，这对CPU来说十分慢（相较之于访问寄存器来说）
2. 段描述符格式奇怪，一个数据需要分三个地方存储，这对于CPU来说无疑更加麻烦
   
所以针对上述两个问题，80286的保护模式给出了解决方案，那就是采用缓存技术，将段信息用一个寄存器来保存，这就是段描述符寄存器（Descriptor Cache Registers）。对程序员不可见，如同Cache一样。
以下给出各CPU版本下的段描述符寄存器结构：
![](http://imgsrc.baidu.com/super/pic/item/b03533fa828ba61e0fc138eb0434970a314e59c3.jpg)

### 2,保护模式寻址变化
在实模式之前，寻址方式有相对寻址，基址寻址、变址寻址、直接寻址、间接寻址等（这里对于学习过计算机组成原理的同学应该不在话下，如果这里不熟也可以网上翻阅，百度、csdn都可以，CSDN虽然差评很多，但是对于一些基础知识也是有很多好的博客的），具体形式参考以下代码：
```
mov ax, [si] 
mov ax, [di] 
mov ax, [bx] 
mov ax, [bx+si] 
mov ax, [bx+si+Oxl234] 
mov ax, [bx+di] 
mov ax, [bx+di +Oxl2 34] 
```
实模式下对于内存寻址来说，其中的基址寻址、变址寻址、基址变址寻址，这三种形式中的基址寄存器只能是 bx ，bp，变址寄存器只能是si 、 di ，也就是说，只能用这 个寄存器。其中 bx 默认的段寄存器是由，它经常用于访问数据段， bp默认的段寄存器是 SS ，它经常用于访问栈。

总之在实模式下每个寄存器有其独特的使命，寄存器不能随便瞎用，否则会报错。

但是在保护模式下这写寄存器对于内存寻址就不会这么刻板，而是所有32位寄存器都可以参与内存寻址。

### 3. 模式反转
由于我们的CPU运行模式有实模式和保护模式两种，为了兼顾他们，所以设计CPU十分困难。CPU处于实模式下时，虽然一切都是16位寄存器，但这并不代表寄存器只有16位，他2依然可以使用32位的资源，也就是说他们的资源是互通的，无论在哪种模式下都可以使用他们。但是我们如何知道同一个汇编语句是在哪种模式之下呢。
首先我们来看看指令格式，如下图：
![](http://imgsrc.baidu.com/super/pic/item/267f9e2f0708283810962cd0fd99a9014d08f15f.jpg)
这里给出一个简单的例子，比如在表示bx寄存器的时候，实模式是使用010来表示，但是在保护模式的时候010就代表了ebx，但是相同的指令格式，CPU并不知道你到底是实模式还是保护模式下，所以这就得交给我们的编译器来决定。
因此编译器提供了伪指令[bits]。现在我们的Loader还是在实模式下运行，但是他要实现从实模式下到保护模式的转化，所以在Loader这个程序中需要同时存在实模式和保护模式的代码。这里给出[bits]伪指令的功能：
+ bits的指令格式为[bits 16]或[bits 32]
+ [bits 16]是告诉编译器，下面的代码请给出编译成16位的机器码
+ [bits 32]是告诉编译器，下面额代码请给出编译成32位的机器码

“下面的代码”就是从这个bits标签到下一个bits标签所包含的范围。
说完模式反转的基础知识，这里我再给出一般进入保护模式的方法：
1. 打开A20
2. 加载gdt
3. 将cr0的pe位置1

这里的几个东西大家看不懂没关系，后面我会细讲。这三个步骤可以不顺序也可以不连续。这里再给出几个模式反转例子供大家参考。


