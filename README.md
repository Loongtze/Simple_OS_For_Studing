## 0x00 基础知识们
今天我们来介绍关于中断的基础知识，理论上经常将中断分为两大类。
### 1.外部中断
一般指CPU外部硬件传来的中断，由于中断源必定为硬件，所以也被称为硬件中断，而我们CPU为了知道外面有人说哎呀我不行了我要中断辣，所以必须得有个传话筒，这里就存在着两个“传话筒”，也就是两根信号线，他们分别是INTR(INTeRrupt)和NMI(Non Maskable Interrupt)
![](http://imgsrc.baidu.com/super/pic/item/2e2eb9389b504fc224d7cac0a0dde71191ef6d6f.jpg)
上图给出了两种信号线的区别，其中INTR收到的信号都是不影响系统运行的，可以随时处理，而NMI收到的信号是必须要立刻处理，NMI收到信号后，一切其他的工作都失去了意义，先把这个中断处理了才是重中之重。
首先我们介绍可屏蔽中断，可屏蔽中断是指的由INTR线传递的中断信号，外部设备如硬盘、网卡等发出的中断都是可屏蔽中断。可屏蔽的意思是此外部设备发出的中断， CPU 可以不理会，因为它不会让系统右机，所以可以通过 eflags寄存器的 IF 位将所有这些外部设备的中断屏蔽。另外，这些设备都是接在某个中断代理设备的，通过该中断代理也可以单独屏蔽某个设备的中断，这是后话，后面会有详细介绍。
然后我们介绍不可屏蔽中断，他是由NMI线传递的中断信号，只要这里传递了中断，计算机就说明遭到了严重的问题，必须立刻处理。此时上述eflags寄存器的IF位对他也毫无影响。

CPU 收到中断后，得知道发生了什么事情才能执行相应的处理办法。这是通过中断向量表或中断描述符表（中断向量表是实模式下的中断处理程序数组，在保护模式下已经被中断描述符表代替，在后面章节中会细说〉来实现的，首先为每一种中断分配一个中断向量号，中断向量号就是一个整数，它就是中断向量表或中断描述符表中的索引下标，用来索引中断项。中断发起时，相应的中断向量号通过 NMI INTR引脚被传入 CPU ，中断向量号是中断向量表或中断描述符表里中断项的下标， CPU 根据此中断向量号在中断向量表或中断描述符表中检索对应的中断处理程序井去执行。

### 2.内部中断
介绍玩外部中断，这里我们来介绍内部的，内部中断又可以继续划分，分为软中断和异常
软中断，就是由软件主动发起的中断，因为它来自于软件，所以称之为软中断。由于该中断是软件运行中主动发起的，所以它是主观上的，井不是客观上的某种内部错误。
下面就是咱们可以发起中断的指令：
+ int (8位数据)：8位可表示256种中断，这条指令在之后我们会经常使用
+ int3 ：调试断点指令，它所出发的中断向量号是3,当我们使用gdb或bochs进行调试时，实际上就是调试器fork了一个子进程。调试器中设置断点实际上就是父进程修改子进程，将其用int3指令替换，从而实现中断使得咱们可以停在断点，
+ into ：这是中断溢出指令，它所触发的中断向量号是4。不过，能否引发4号中断是要看 eflags志寄存器中的 OF 位是否为1，如果是1才会引发中断，否则该指令悄悄地什么都不做，低调得很
+ bound ：这是检查数组索引越界指令，它可以触发5号中断，用于检查数组的索引下标是否在上下边界之内。该指令格式是“bound 16/32 位寄存器， 16/32 位内存飞目的操作数是用寄存器来存储的，其内容是待检测的数组下标值。源操作数是内存，其内容是数组下标的下边界和上边界 当执行 bound 指令时，若下标处于数组索引的范围之外，则会触发5号中断。
+ ud2 ：触发6号中断，无实际用途

而异常是我们程序运行时出现的错误，他同样不受eflags寄存器中的标志位的影响，也就是说不可屏蔽，因为都出现错误了计算机说想看不见也不行，异常可以分为以下3种：
1. Fault，故障，可修复，例如缺页异常
2. Trap，陷阱，自己想陷入中断，所以中断返回后执行下一条指令。
3. Abort, 终止，无法修复，操作系统为求自保，只能把该程序从进程表移除

这里给出我们异常与中断的汇总表供大家参考：
![](http://imgsrc.baidu.com/super/pic/item/a044ad345982b2b70acc5c0174adcbef77099ba0.jpg)

其中我们的中断向量号的作用类似于选择子，都是某个表的下标。

### 3.中断描述符表
得，又来一个表，中断描述符表（Interrupt Descriptor Table，IDT）是保护模式下存放中断处理程序入口的一个表，这里注意同实模式下的中断表区分开来。
而中断描述符表中不止有中断描述符，还有任务门描述符和陷阱门描述符。而由于所有的描述符都指向了一段程序，这里就体现出来他与GDT的不同，所以在这里的描述符有个另外的名字，那就是“门”。
所有的门都是8字节，这里我们来回忆一下描述符中的字段类型，type字段指明了该描述符的类型，其中的S位若为1则说明该段为数据段，为0则表示为系统段，咱们这里的门就属于系统段
这里给出之前门的描述符结构：
![](http://imgsrc.baidu.com/super/pic/item/c75c10385343fbf2b2148de6f57eca8065388f3e.jpg)
![](http://imgsrc.baidu.com/super/pic/item/32fa828ba61ea8d3b2195fc1d20a304e251f583f.jpg)
![](http://imgsrc.baidu.com/super/pic/item/adaf2edda3cc7cd99b181f1c7c01213fb80e9139.jpg)
![](http://imgsrc.baidu.com/super/pic/item/35a85edf8db1cb13755e17d69854564e92584b3b.jpg)
当然这里为了避免忘记，同时给出之前段描述符的概念结构：
![](http://imgsrc.baidu.com/super/pic/item/5882b2b7d0a20cf453bb011b33094b36adaf99cf.jpg)
可以看出这里结构都是类似，只不过有的不同位的功能发生了变化，这也导致了我们的门可以正常放在段描述表或者说中断描述表中了。
这里提一嘴各门的区别：
1. 任务门：配合TSS使用实现特权级切换，可存放在GDT，LDT，IDT中,描述符中任务门的type字段二进制为0101
2. 中断门：包含中断处理程序所在段的段选择子以及偏移，当通过此方式进入中断之后，eflags寄存器的IF位自动置0,也就是关中断，防止中断嵌套。Linux就是使用中断门实现系统调用，也就是著名的int 0x80。中断门只允许存放在IDT中。描述符中中断门的type字段二进制为1110
3. 陷阱门：类似于中断门，区别就是IF位不会置0,只允许存放在IDT中，陷阱门的type字段二进制为1111
4. 调用门：提供用户进程进入特权0级，其DPL为3，只能用call或jmp指令调用，可以安装在GDT和LDT中，type值为1100

既然内存中应该存在一个IDT供我们使用，所以我们寻找他的方式类似与GDT，也就是说有一个寄存器来存放IDT的物理地址，这个寄存器就是IDTR，下面是IDTR的结构：
![](http://imgsrc.baidu.com/super/pic/item/d53f8794a4c27d1eeada5b015ed5ad6edcc43872.jpg)
其中低16位代表段界限，高32位代表IDT物理地址，16位的表界限可以表示2^16B，也就是64KB，而一个门占8字节，所以一共可以存放64KB/8B = 8192个，这里注意虽然GDT第0表项为全0不可用，但IDT却无此限制，中断向量为0表示除法错。
同加载GDTR一样，加载IDTR也有个专门的指令--lidt，其用法是
lidt 48位内存数据

### 4.中断处理过程及保护
中断过程分为CPU外和CPU内两部分
CPU外： 外部设备的1中断由中断代理芯片接收，处理后将该中断的中断向量号发送到CPU
CPU内： CPU执行该中断向量号对应的中断处理程序
这里我们先讨论处理器内部的内容
1. 处理器根据中断向量号定位中断门描述符。
2. 处理器进行特权级检查
由于中断是通过中断向量号通知到处理器的，中断向量号只是个整数，其中并不包含RPL，所以在对由中断引起的特权级转移做特权级检查中不会涉及RPL。中断门的特权级检查同调用门类似，对于软件主动发起的软中断，当前特权级CPL必须在门描述符和目标代码段DPL之间，下面分情况解释
+ 若是由软中断int n，int3，into引发的中断，这些是由用户自主发起的，所以处理器要检查当前特权级和门描述符DPL，这是检查进门的特权下限，若是检查通过，也就是CPL特权级是高于门DPL的，那么将进入下一步“门框”的检查，否则处理器将会报出异常
+ 这一步检查特权级的上限“门框”，处理器要检查当前特权级CPL和门描述符中所记录选择子对应的目标代码段的DPL，若CPL特权级小于目标代码段的DPL，则检查通过，否则处理器引发异常。
+ 若中断是由外部设备和异常引起的，则只检查CPL和目标代码段的DPL，若CPL小于目标代码段特权，则检查通过，否则处理器引发异常。
3. 执行中断处理程序
特权级检查通过后，将门描述符目标代码段选择子加载到代码段寄存器cs中，把门描述符中的偏移地址加载至EIP中，然后执行中断处理程序。
过程如下图所示：
![](http://imgsrc.baidu.com/super/pic/item/55e736d12f2eb9387366193790628535e4dd6fe8.jpg)

中断发生后，eflags中的NT位和TF位会被置0,若中断对应的是中断门，则在进入中断门后eflags的IF位会自动置0以此来防止中断嵌套，但是我们依然可以在中断处理中将IF位打开，我们先前说过修改eflags寄存器的内容只能通过pushf压栈然后恢复栈来修改，但此关系到内存访问了，效率想必是十分低效的，所以处理器专门提供了一个修改IF位的指令（开小灶是吧）。那就是cli和sti，其中cli指令使得IF位为0,sti指令使得IF为1,分别称之为关中断和开中断。
IF位只能限制外部设备中断，而对其他影响系统正常运行的中断都无效。
这里我们再来解释TF，即Trap Flag，也就是陷阱标志位，这用在调试环境中，当TF为0表示禁止单步执行。
而NT表示Nest Task Flag，即任务嵌套位，用来标记任务嵌套调用的情况。任务嵌套调用就是指CPU挂起当前的任务转而去执行另外一个任务，待到该任务执行完再转回去执行之前的任务，而CPU能如此是因为他会执行以下操作：
1. 将旧任务的TSS段选择子写到新任务TSS中的“上一个任务TSS的指针”字段中。
2. 将新任务eflags寄存器中NT置为1,表示新任务之所以呢能够执行是因为有别的任务调用了他

而CPU从新任务返回到旧任务是通过iret指令，他有两个功能，一个是中断返回，一个是返回旧任务，所以这里就需要用到NT位，因为执行iret的时候会去检查NT位的值，若为1则说明当前任务是嵌套执行的，若为0则说明是在中断处理环境下，于是执行正常的中断退出流程

### 5.中断压栈
中断发生时，处理器收到一个中断向量，根据该中断向量号在IDT中的偏移，然后找到对应的门然后通过其中的选择子，然后将该选择子移入CS中，再将门描述符中的偏移字段移入EIP。这时由于CS和EIP会被刷新，所以处理器会将被中断的程序的CS和EIP保存到当前中断处理程序使用的栈当中，至于说中断处理用的哪个栈，这里不好说，因为中断在任何特权级下都有可能发生，所以我们除了保存CS，EIP外还需要保存EFLAGS，如果涉及到特权级变化还要压入SS和ESP寄存器，下面来介绍寄存器入栈情况以及顺序：
1. 当处理器通过中断向量找到对应的中断描述符后，比较CPL和中断门描述符中选择子对应目标代码段的DPL对比，若发现向高特权级转移，则需要切换到高特权级的栈，这也意味着当我们执行完中断处理程序后需要恢复旧栈才行。因此处理器先临时保存旧SS和ESP的值，记做SS_old,和ESP_old,然后在TSS中寻找到对应目标代码段同特权级的栈加载到寄存器SS和ESP中，记作SS_new,和ESP_new，再将临时保存的SS_old和ESP_old压栈备份，如图所示：
![](http://imgsrc.baidu.com/super/pic/item/1c950a7b02087bf48e04382cb7d3572c10dfcf0f.jpg)
2. 然后压入EFLAGS寄存器，如下图
![](http://imgsrc.baidu.com/super/pic/item/f2deb48f8c5494ee05cc60dc68f5e0fe98257e0d.jpg)
3. 然后因为需要切换代码段，所以也要将CS和EIP保存到栈中进行备份，用以在中断结束后恢复被中断的进程，如下图：
![](http://imgsrc.baidu.com/super/pic/item/5882b2b7d0a20cf4e358911a33094b36adaf992f.jpg)
4. 某些异常会爆出错误码，这个错误码是用于报告一场是在哪个段上发生的，也就是发生异常的位置，所以错误码中包含选择子等信息。他一般紧跟EIP后入栈，记为ERROR_CODE.如下图：
![](http://imgsrc.baidu.com/super/pic/item/83025aafa40f4bfba811f191464f78f0f6361835.jpg)

处理器执行完中断处理程序后需要返回到被中断进程，也就是使用iret指令进行弹站，这里需要保证上述顺序。如果说有中断错误码，处理器并不知晓，所以这需要我们手动将其跳过，也就是说当我们准备用iret指令返回时当前栈指针必须得指向栈中备份的EIP_old所在的位置，这样才能依次对号入座。

### 6.中断错误码
错误码用来指明中断发生在哪个段上，所以说错误码最主要的部分是选择子，这里给出错误码的结构：
![](http://imgsrc.baidu.com/super/pic/item/9345d688d43f879494a326eb971b0ef41ad53a92.jpg)
可以看出和选择子有9分的相似（ ，其中我们可以看到他的低2位有所不同，他代表的不是RPL，而是IDT和EXT，这里依次解释
+ EXT表示EXTernal event,即外部事件，用来指明中断源是否来自处理器内部，如果中断源是不可屏蔽中断NMI或外部设备，EXT为1,否则为0。
+ IDT表示选择子是否指向中断描述符表IDT，IDT位为1则表示此选择子指向中断描述符表，否则指向GDT或者是IDT

其中TI和选择子TI是一致的，为0知指选择子是从GDT中检索描述符，为1是从LDT中检索，而这个位起效的前提是IDT为0。
通常能够压入错误码的中断属于中断向量号在0～32之内的异常，而外部33～255之间和int软中断通常不会产生错误码，因此也不会产生错误码。

## 0x01 可编程中断控制器8259A
这里我们来介绍一个可编程中断控制器，我们以后要通过他来完成进程的调度，而8259A的功能是负责所有来自外设的中断。
### 1.简介
上节我们说到CPU为了接受到外部的可屏蔽中断，需要一根INTR引线，而这个“传话筒”只有一根却要接受多种外设传来的信号，例如打印机，声卡等，我们的CPU只能串行的执行任务，那么如果一群设备同时发送中断信号该怎么办呢，这时我们必须要进行一个中断仲裁，以此来决定CPU先接受哪个中断信号。所以我们需要一个专业的人来做专业的事，这个专业的人就是我们的中断代理，由他来负责对所有中断仲裁。

咱们介绍的8259A就是中断代理的一种
Intel处理器共有256个中断，可是8259A只可以管理8个中断，所以他们将多个8259A控制器组合，这里被成为级联。这里n个8259A进行级联可支持7n+1个中断源，级联时之恩那个有一片是主片master，其余均为从片。来自从片的中断只能传递给主片，再由主片传递给CPU。
每个独立外设所发出的中断只有接在中断请求（IRQ：Interrupt ReQuest）信号线上才会被CPU知晓。
这里我们来解释什么是级联，由于我们单个8259A芯片只有8个终端请求信号线：IRQ0～IRQ7,这肯定是不够的，所以我们用一种组合的方式来进行扩展，这就类似于我们平时的交换机，如果一个交换机无法支持数量众多的主机相连的话，我们会在交换机上再连个交换机，然后现在就相当与多了很多端口供主机相连，这也就解释了为啥n个控制器可以支持7n+1个中断而不是8n了。如下图：
![](http://imgsrc.baidu.com/super/pic/item/f9dcd100baa1cd1153a218e5fc12c8fcc2ce2dda.jpg)
而我们个人的电脑中一般只有两片8259A芯片，我们同样会将其进行级联，所以共可用中断15个，这里给出家用计算机中的级联结构：
![](http://imgsrc.baidu.com/super/pic/item/94cad1c8a786c917687938fc8c3d70cf3ac757f8.jpg)
每个外设发出中断信号他都会以为是发送到了INTR信号线上，但其实他是发给了中断代理芯片，然后再由代理传送信号到CPU的INTR信号线。然后我来介绍8259的内部结构，先给出示意图：
![](http://imgsrc.baidu.com/super/pic/item/838ba61ea8d3fd1f4e58c8ff754e251f94ca5fa5.jpg)
+ INT:
